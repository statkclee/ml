---
layout: page
title: xwMOOC 기계학습
subtitle: 네트워크 데이터
output:
  html_document: 
    keep_md: yes
  pdf_document:
    latex_engine: xelatex
mainfont: NanumGothic
---
 
``` {r, include=FALSE}
source("tools/chunk-options.R")
```

### 1. 네트워크 데이터 구조

네트워크 데이터는 **노드(Node)** 와 **엣지(Edge)** 로 구성된다. 
노드 데이터는 네트워크 노드에 대한 상세 정보가 담겨있다.
반면에 엣지 정보는 연결된 링크 정보를 담고 있는데 `from`, `to` 형식으로
데이터를 담을 수도 있고, 노드간의 관계를 관계 없음은 `0`, 관계 있음은 `1`로
표현한다.

첫번째 네트워크 데이터 형식 표현을 **Edgelist** 라고 하고, 두번째 
데이터 표현방법을 **행렬(Matrix)** 이라고 부른다.

두가지 형태를 갖는 데이터를 불러 읽어오자.


``` {r network-data-import, warning=FALSE}
suppressMessages(library(readr))
suppressMessages(library(dplyr))
#-----------------------------------------------------------------------
# edgelist

nodes <- read_csv("https://raw.githubusercontent.com/kateto/R-Network-Visualization-Workshop/master/Data/Dataset1-Media-Example-NODES.csv", col_names = TRUE)
links <- read_csv("https://raw.githubusercontent.com/kateto/R-Network-Visualization-Workshop/master/Data/Dataset1-Media-Example-EDGES.csv", col_names = TRUE)

#-----------------------------------------------------------------------
# 행렬

nodes2 <- read_csv("https://raw.githubusercontent.com/kateto/R-Network-Visualization-Workshop/master/Data/Dataset2-Media-User-Example-NODES.csv", col_names = TRUE)
links2 <- read_csv("https://raw.githubusercontent.com/kateto/R-Network-Visualization-Workshop/master/Data/Dataset2-Media-User-Example-EDGES.csv", col_names = TRUE)

#-----------------------------------------------------------------------
# 데이터 살펴보기
#-----------------------------------------------------------------------

head(nodes)
head(links)
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))

# 데이터 중복 처리 : 총합
links <- links %>% group_by(from, to, type) %>%  
                   summarise(weight = sum(weight)) %>% 
                   arrange(from, to)
```


`head(nodes)` 명령어를 통해서 살펴보면 `head(nodes2)`와 별다른 차이가 없다.

``` {r network-data-str-node, warning=FALSE}
head(nodes)
head(nodes2)
```

반면에 엣지 정보, 링크 정보는 하나는 `from`, `to` 형식으로, 다른 하나는 
행렬로 표현된다는 점에서 차이가 있다.

``` {r network-data-str-edge, warning=FALSE}
head(links)
head(links2)
```

*igraph* 팩키지로 데이터를 시각화를 해본다. 가장 먼저
노드와 엣지 데이터프레임을 [igraph](http://igraph.org/) 네트워크 객체로 변환해야 된다.
`graph.data.frame` 함수가 노드와 엣지 데이터프레임 자료형을 
igraph 네트워크 객체로 변환하는데 사용된다.

`graph.data.frame` 함수에 인자를 두개 넣는다. 

* **d** : 네트워크 엣지(링크)를 넣어 넘긴다. `from`, `to` 형식으로 칼럼 두개가 먼저 정의되고,
`weight`, `type`, `label` 등 엣지를 표현하는 다른 정보가 나머지 칼럼에 담기게 된다.
* **vertices** : 노드 id 로 첫번째 칼럼이 정의되고, 노드를 표현하는 다른 정보가 순차적으로 
나머지 칼럼에 담기게 된다.

``` {r network-convert-data, warning=FALSE}
library(igraph)

net <- graph.data.frame(links, nodes, directed=T)
net
```

* `IGRAPH DNW- 17 49 -- ` : 
    * D 혹은 U : 방향성 있는 그래프 혹은 방향성 없는 그래프를 기술
    * N : 노드가 `name` 속성을 갖는 것을 기술
    * W : 가중값이 있는 그래프로 엣지에 `weight` 속성이 있음을 기술
    * B : 이분(Bipartite, two-mode) 그래프로 노두가 `type` 속성이 있음을 기술
    * 17 49 : 노드가 17, 엣지가 49 개가 그래프에 존재함을 기술
* `attr: name (v/c), media (v/c), media.type (v/n), type.label (v/c), audience.size (v/n), type (e/c), weight (e/n)` : 
    * (g/c) : graph-level character attribute
    * (v/c) : vertex-level character attribute
    * (e/n) : edge-level numeric attribute
    * (e/c) : edge-level character attribute

`E()` 함수를 통해 네트워크 객체에 포함된 엣지 정보를 추출한다.
`V()` 함수를 통해 네트워크 객체에 포함된 노드 정보를 추출한다.
직접 행렬 원소를 뽑아내는 것도 가능하다.

``` {r network-data-query, warning=FALSE}
#------------------------------------------------------------------------
# 네트워크 객체 조회

E(net)       # "net" 객체 엣지정보 조회 
V(net)       # "net" 객체 노드정보 조회
E(net)$type  # 엣지 속성 "type"
V(net)$media # 노드 속성 "media"

# 직접 네트워크 행렬을 조작
net[1,]
net[5,7]
```

### 2. 네트워크 데이터 시각화

`plot(net)` 명령어를 통해 시각화를 할 경우, 중복되는 엣지도 많고 해서 간략화할 필요가 있다.
이때 사용되는 명령어가 `simplify()` 함수다.

``` {r network-viz-simplify, warning=FALSE}
# plot(net)
net <- simplify(net, remove.multiple = FALSE, remove.loops = TRUE) 
# net <- simplify(net, edge.attr.comb=list(Weight="sum","ignore"))
plot(net, edge.arrow.size=.01,vertex.label=NA)
```

`dev.off()`로 장치를 초기화하고, `vertex.label.family` 인자를 통해 글꼴도 설정한다.

``` {r network-viz-simplify-plots, warning=FALSE}
dev.off()
par(mfrow=c(1,2))
plot(net, edge.arrow.size=.01,vertex.label=NA)
plot(net, edge.arrow.size=.01, vertex.label.family="NanumMyeongjo")
```

#### 2.1. `igraph` 주요 설정 매개변수

| 노드(Node)            |   노드 매개변수 설명                                                |
|-----------------------|---------------------------------------------------------------------|
| vertex.color	 		| Node color |
| vertex.frame.color 	| Node border color |
| vertex.shape	 		| One of “none”, “circle”, “square”, “csquare”, “rectangle”, “crectangle”, “vrectangle”, “pie”, “raster”, or “sphere” |
| vertex.size	 		| Size of the node (default is 15) |
| vertex.size2	 		| The second size of the node (e.g. for a rectangle) |
| vertex.label	 		| Character vector used to label the nodes |
| vertex.label.family   | 	Font family of the label (e.g.“Times”, “Helvetica”) |
| vertex.label.font	 	| Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol |
| vertex.label.cex	 	| Font size (multiplication factor, device-dependent) |
| vertex.label.dist	 	| Distance between the label and the vertex |
| vertex.label.degree   | 	The position of the label in relation to the vertex, where 0 right, “pi” is left, “pi/2” is below, and “-pi/2” is above |

| 엣지(Edge)            | 엣지 매개변수 설명                                                  |
|-----------------------|---------------------------------------------------------------------|
|edge.color	 			| Edge color |
|edge.width	 			| Edge width, defaults to 1 |
|edge.arrow.size		| Arrow size, defaults to 1 |
|edge.arrow.width	 	| Arrow width, defaults to 1 |
|edge.lty	 			| Line type, could be 0 or “blank”, 1 or “solid”, 2 or “dashed”, 3 or “dotted”, 4 or “dotdash”, 5 or “longdash”, 6 or “twodash” |
|edge.label	 			| Character vector used to label edges |
|edge.label.family	 	| Font family of the label (e.g.“Times”, “Helvetica”) |
|edge.label.font		| Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol |
|edge.label.cex	 		| Font size for edge labels |
|edge.curved	 		| Edge curvature, range 0-1 (FALSE sets it to 0, TRUE to 0.5) |
|arrow.mode	 			| Vector specifying whether edges should have arrows, possible values: 0 no arrow, 1 back, 2 forward, 3 both |


| 기타                  | 기타 매개변수 설명                                                  |    	 
|-----------------------|---------------------------------------------------------------------|
| margin	   |  Empty space margins around the plot, vector with length 4   |
| frame	 	   |  if TRUE, the plot will be framed   |
| main	 	   |  If set, adds a title to the plot   |
| sub	 	   |  If set, adds a subtitle to the plot   |


#### 2.2. 노드와 엣지에 매개변수 반영 

노드와 엣지를 네트워크 시각화에 매개변수를 통해 반영하는 방식은 두가지가 있다.
먼저 `plot()` 함수에 노드와 엣지 매개변수를 적어 넣는다.

`edge.arrow.size=.4` 엣지 화살표 크기를 .4로 설정하고, 엣지에 곡선을 .3으로 반영한다.

``` {r network-node-edge-param-type1-ex01, warning=FALSE}
plot(net, edge.arrow.size=.4, edge.curved=.3)
```

엣지 색상은 오렌지색상으로, 노드는 회색으로, 노드 외곽 색상은 흰색으로 설정한다.
노드 라벨을 `V(net)$media` 변수를 사용하고 노드 라벨 색상은 검정색으로 설정한다.

``` {r network-node-edge-param-type1-ex02, warning=FALSE}
plot(net, edge.arrow.size=.2, edge.color="orange",
     vertex.color="dark gray", vertex.frame.color="#ffffff",
     vertex.label=V(net)$media, vertex.label.color="black") 
```

두번째 방식은 igraph 객체에 속성으로 추가하는 것이다.
예를 들어, 미디어 유형에 따라 네트워크 노드에 색상을 추가하고, 
연결 중앙성(Degree Centrality, 링크가 많으면 더 큰 노드)에 따라 크기를 조정한다.
가중치(weight)에 따라 엣지 선폭도 설정한다.

``` {r network-node-edge-param-type2, warning=FALSE}
#------------------------------------------------------------------------
# 03.02. 첫번째 방식: igraph 객체에 속성으로 적용

# 미디어 유형에 따른 색상 생성:
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]

# 노드 연결 중앙성에 따른 노드 크기 설정:
deg <- igraph::degree(net, V(net), mode="all")
V(net)$size <- deg*3

# audience size 값을 사용해서 노드 크기 설정:
V(net)$size <- V(net)$audience.size*0.6

# 노드 ID로 현재 라벨이 설정되어 있는데, 라벨이 표시되지 않도록 설정:
V(net)$label <- NA

# 엣지 선폭을 가중치(weight)에 따라 설정:
E(net)$width <- E(net)$weight/2

# 화살표 크기와 엣지 색상을 변경:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
E(net)$width <- 1+E(net)$weight/12

plot(net) 
colrs <- c("gray50", "tomato", "gold")
legend(x=-1.5, y=-1.1, c("Newspaper","Television", "Online News"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)
```

노드 라벨을 적용하는 것이 의미론적인 면에서 더 의미가 있을 수 있다.

``` {r network-node-edge-param-label, warning=FALSE}
#------------------------------------------------------------------------
# 03.03. 노드 라벨를 활용한 네트워크 시각화

par(mfrow=c(1,1))
plot(net, vertex.shape="none", vertex.label=V(net)$media, 
     vertex.label.font=2, vertex.label.color="gray40", edge.arrow.size=.1,
     vertex.label.cex=.7, edge.color="gray85", edge.width	= 1+E(net)$weight/12)
```

엣지 색상을 노드와 맞춰 시각화를 함으로써 노드와 엣지를 함께 이해하는 것도 가능하다.

``` {r network-node-edge-param-color, warning=FALSE}
#------------------------------------------------------------------------
# 03.04. 엣지를 노드에 맞춰 색상을 맞춤

edge.start <- ends(net, es=E(net), names=F)[,1] # get the "from" node
edge.col <- V(net)$color[edge.start]

plot(net, edge.color=edge.col, edge.curved=.1)
```

### 3. 네트워크 배치(Layout)

네트워크 배치(Layout)는 네트워크 노드에 대한 좌표를 반환하는 단순히 알고리즘이라고 볼 수 있다.


`barabasi.game` 함수를 사용해서 80개 노드를 갖는 그래프를 통해 네트워크 배치에 대한
탐색을 시작해 본다. 선호적 연결원리(Preferential attachment)를 따라 노드 하나에서 
시작해서 체계적으로 증가시켜 나간다.

``` {r network-layout-barabasi, warning=FALSE}
##=======================================================================
## 01. 네트워크 배치
##=======================================================================
source("02.code/01-clean.R")
source("02.code/04-network-viz.R")

# 바라바시 게임 (Preferential attachment)
library(igraph)

net.bg <- barabasi.game(80) 
V(net.bg)$frame.color <- "white"
V(net.bg)$color <- "orange"
V(net.bg)$label <- "" 
V(net.bg)$size <- 10
E(net.bg)$arrow.mode <- 0
plot(net.bg)

# layout 설정
plot(net.bg, layout=layout.random)

# 사전에 노드좌표를 설정
l <- layout.circle(net.bg)
plot(net.bg, layout=l)

# 개발자가 직접 설정
l <- matrix(c(1:vcount(net.bg), c(1, vcount(net.bg):2)), vcount(net.bg), 2)
plot(net.bg, layout=l)

# 노드 배치 내장함수: 무작위
l <- layout.random(net.bg)
plot(net.bg, layout=l)

# 노드 배치 내장함수: 원
l <- layout.circle(net.bg)
plot(net.bg, layout=l)

# 노드 배치 내장함수: 
l <- layout.sphere(net.bg)
plot(net.bg, layout=l)


# 1. Fruchterman-Reingold: Force-directed 배치 알고리즘
l <- layout.fruchterman.reingold(net.bg, repulserad=vcount(net.bg)^3, 
                                 area=vcount(net.bg)^2.4)
par(mfrow=c(1,2),  mar=c(0,0,0,0))
plot(net.bg, layout=layout.fruchterman.reingold)
plot(net.bg, layout=l)

# 2. Kamada Kawai 배치 알고리즘
l <- layout.kamada.kawai(net.bg)
plot(net.bg, layout=l)

l <- layout.spring(net.bg, mass=.5)
plot(net.bg, layout=l)

# 3. LGL 배치 알고리즘
plot(net.bg, layout=layout.lgl)

# 4. Fruchterman-Reingold: 수동 설정

l <- layout.fruchterman.reingold(net.bg)
l <- layout.norm(l, ymin=-1, ymax=1, xmin=-1, xmax=1)

par(mfrow=c(2,2), mar=c(0,0,0,0))
plot(net.bg, rescale=F, layout=l*0.4)
plot(net.bg, rescale=F, layout=l*0.6)
plot(net.bg, rescale=F, layout=l*0.8)
plot(net.bg, rescale=F, layout=l*1.0)

# igraph 내장 배치 알고리즘

layouts <- grep("^layout\\.", ls("package:igraph"), value=TRUE) 
layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|gem", layouts)]

par(mfrow=c(3,6), mar=c(0,0,0,0))
for(layout in layouts) {
  print(layout)
  l <- do.call(layout, list(net))
  plot(net, edge.arrow.mode=0, layout=l, main=layout) }
```

